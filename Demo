import java.util.Scanner;

public class CircleIntersectionArea {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 输入第一个圆的参数
        int centerX1 = scanner.nextInt();
        int centerY1 = scanner.nextInt();
        int radius1 = scanner.nextInt();

        // 输入第二个圆的参数
        int centerX2 = scanner.nextInt();
        int centerY2 = scanner.nextInt();
        int radius2 = scanner.nextInt();

        // 计算圆心之间的距离
        double distance = Math.sqrt(Math.pow(centerX2 - centerX1, 2) + Math.pow(centerY2 - centerY1, 2));

        double intersectionArea = 0.0;

        // 判断圆的交集情况
        if (distance >= radius1 + radius2) {
            // 两圆互不相交
            intersectionArea = 0.0;
        } else if (distance <= Math.abs(radius1 - radius2)) {
            // 一个圆完全包含另一个圆
            int smallerRadius = Math.min(radius1, radius2);
            intersectionArea = Math.PI * Math.pow(smallerRadius, 2);
        } else {
            // 两圆部分相交，计算交集面积
            double r1Squared = Math.pow(radius1, 2);
            double r2Squared = Math.pow(radius2, 2);

            double angle1 = 2 * Math.acos((r1Squared + Math.pow(distance, 2) - r2Squared) / (2 * radius1 * distance));
            double angle2 = 2 * Math.acos((r2Squared + Math.pow(distance, 2) - r1Squared) / (2 * radius2 * distance));

            double area1 = 0.5 * r1Squared * (angle1 - Math.sin(angle1));
            double area2 = 0.5 * r2Squared * (angle2 - Math.sin(angle2));

            intersectionArea = area1 + area2;
        }

        // 输出结果，保留6位小数
        System.out.printf("%.6f%n", intersectionArea);

        scanner.close();
    }
}





import java.util.Scanner;

public class CityClusters {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 输入城市数量和连接数
        int matinput_row = scanner.nextInt();
        int matinput_col = scanner.nextInt();
        scanner.nextLine(); // 跳过换行符

        // 初始化邻接矩阵
        int[][] matrix = new int[matinput_row][matinput_col];
        for (int i = 0; i < matinput_row; i++) {
            String[] row = scanner.nextLine().split(" ");
            for (int j = 0; j < matinput_col; j++) {
                matrix[i][j] = Integer.parseInt(row[j]);
            }
        }

        // 标记访问的数组
        boolean[] visited = new boolean[matinput_row];
        int clusters = 0;

        // 遍历所有城市
        for (int i = 0; i < matinput_row; i++) {
            if (!visited[i]) {
                // 如果城市未访问，开始DFS并计数
                dfs(matrix, visited, i);
                clusters++;
            }
        }

        // 输出总的集群数量
        System.out.println(clusters);

        scanner.close();
    }

    // 深度优先搜索
    private static void dfs(int[][] matrix, boolean[] visited, int city) {
        visited[city] = true; // 标记当前城市为已访问

        // 遍历当前城市的所有连接
        for (int i = 0; i < matrix[city].length; i++) {
            if (matrix[city][i] == 1 && !visited[i]) {
                dfs(matrix, visited, i); // 递归访问未访问的连接城市
            }
        }
    }
}
